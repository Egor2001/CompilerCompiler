//Warning! Do not edit this file!
//This file was auto - generated by FLEXX
//Edit FLEXX input file instead
#ifndef FLEXXER_H
#define FLEXXER_H
#include <string_view>
#include <charconv>
#include <vector>
#include <array>
#include "SFlexxTerm.h"
using YYTERM = SFlexxTerm;
enum ETermType
{
	TERMS_CNT,
	TERM_lit,
	TERM_imm
};
struct SLexem
{
    ETermType type;
    YYTERM    term;
};
struct STerm
{
    std::size_t try_match(const std::string_view& text_view) const;
    
    ETermType type;
    std::string_view name;
    std::string_view expr;
};
std::size_t STerm::try_match(const std::string_view& text_view) const
{
    std::size_t result = 0u;
    if (text_view.compare(0u, expr.size(), expr) == 0)
        result = expr.size();
    
    return result;
}
const std::array<STerm, TERMS_CNT>GlobalTermArray = {
    {
    }
};
std::size_t flexx_lexem(const std::string_view& text_view,
                        std::vector<SLexem>& flexx_vec)
{
    std::size_t result = 0u;
    std::size_t subresult = 0u;
    SLexem cur_lexem = {};
    if (!text_view.empty() && std::isalpha(text_view.front()))
    {
        subresult = 0u;
        while (subresult < text_view.size() &&
               std::isalnum(text_view[subresult]))
            ++subresult;
    
        if (subresult > result)
        {
            result = subresult;
            auto term_view = text_view.substr(0u, result);
            cur_lexem.type = TERM_lit;
            cur_lexem.term = SFlexxTerm(std::string(term_view.data(), term_view.size()));
        }
    }
    else if (!text_view.empty() && 
             std::isdigit(text_view.front()))
    {
        subresult = 0u;
        while (subresult < text_view.size() &&
               std::isdigit(text_view[subresult]))
            ++subresult;
    
        if (subresult > result)
        {
            auto beg = text_view.data();
            auto end = text_view.data() + subresult;
            int32_t data = 0;
            auto [next_ptr, err_code] = std::from_chars(beg, end, data);
            if (err_code == std::errc{})
            {
                result = subresult;
                cur_lexem.type = TERM_imm;
                cur_lexem.term = SFlexxTerm(data);
            }
        }
    }
    if (result)
        flexx_vec.push_back(cur_lexem);
    
    return result;
}
std::size_t flexx(std::string_view text_view,
                  std::vector<SLexem>& flexx_vec)
{
    std::size_t result = 0u;
    std::size_t skip = 0u;
    while ((skip = flexx_lexem(text_view, flexx_vec)))
    {
        text_view.remove_prefix(skip);
        result += skip;
        
        skip = text_view.find_first_not_of(" \t\r\n");
        text_view.remove_prefix(std::min(skip, text_view.size()));
        result += skip;
    }
    
    return result;
}
#endif //FLEXXER_H
