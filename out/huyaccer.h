//Warning! Do not edit this file!
//This file was auto - generated by HUYACC
//Edit HUYACC input file instead
#ifndef HUYACCER_H
#define HUYACCER_H
enum ERuleType
{
	RULE_test_rule,
	RULE_lit_rule,
	RULE_imm_rule,
	RULES_CNT
};
#include <string_view>
#include <memory>
#include <vector>
#include <array>
#include "SHuyaccLexem.h"
#include "SFlexxTerm.h"
#include "SHuyaccNode.h"
using YYTERM = SFlexxTerm;
using YYNODE = std::shared_ptr<SHuyaccNode>;
struct SRule
{
    ERuleType type;
    std::string_view name;
    std::shared_ptr<SHuyaccLexem> expr;
};
const std::array<SRule, RULES_CNT> GlobalRuleArray = {
    {
	{
	    RULE_test_rule,
	    "test_rule",
std::make_shared<SHuyaccLexem>(SHuyaccLexXor(std::make_shared<SHuyaccLexem>(SHuyaccLexRule(RULE_lit_rule)), std::make_shared<SHuyaccLexem>(SHuyaccLexRule(RULE_imm_rule))))
	},
	{
	    RULE_lit_rule,
	    "lit_rule",
std::make_shared<SHuyaccLexem>(SHuyaccLexTerm(TERM_lit))
	},
	{
	    RULE_imm_rule,
	    "imm_rule",
std::make_shared<SHuyaccLexem>(SHuyaccLexTerm(TERM_imm))
	},
    }
};
YYNODE build_huyacc_rule(ERuleType type, const std::vector<YYNODE>& YYLIST);
YYNODE huyacc(const std::vector<SLexem>& term_vec)
{
    YYNODE YYLVAL = {};
    
    SMatchContext context = { 0u, {} };
    
    if (GlobalRuleArray.front().expr && 
        GlobalRuleArray.front().expr->try_match(term_vec, context))
        YYLVAL = build_huyacc_rule(GlobalRuleArray.front().type, 
                                   context.node_vec);
    
    return YYLVAL;
}
YYNODE build_huyacc_term(ETermType type, const SLexem& lexem)
{
    YYNODE result = {};
    if (type == lexem.type)
        result = std::make_shared<SHuyaccNode>(lexem.term);
    else
        result = {};
    
    return result;
}
YYNODE huyacc_test_rule(const std::vector<YYNODE>& YYLIST)
{
    YYNODE YYLVAL = {};
 
    YYLVAL = YYLIST[0];

    return YYLVAL;
}
YYNODE huyacc_lit_rule(const std::vector<YYNODE>& YYLIST)
{
    YYNODE YYLVAL = {};
 
    YYLVAL = YYLIST[0];

    return YYLVAL;
}
YYNODE huyacc_imm_rule(const std::vector<YYNODE>& YYLIST)
{
    YYNODE YYLVAL = {};
 
    YYLVAL = YYLIST[0];

    return YYLVAL;
}
YYNODE build_huyacc_rule(ERuleType type, const std::vector<YYNODE>& YYLIST)
{
    YYNODE result = {};
    switch (type)
    {
    case RULE_test_rule:
        result = huyacc_test_rule(YYLIST);
        break;
    case RULE_lit_rule:
        result = huyacc_lit_rule(YYLIST);
        break;
    case RULE_imm_rule:
        result = huyacc_imm_rule(YYLIST);
        break;
    default:
        result = {};
        break;
    }
    
    return result;
}

#include "SHuyaccLexemImpl.h"

#endif //HUYACCER_H
