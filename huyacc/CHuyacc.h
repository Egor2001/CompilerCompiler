#ifndef CHUYACC_H
#define CHUYACC_H

#include <vector>

#include "../parser/SParseTerm.h"
#include "../parser/SParseRule.h"
#include "CBuilder.h"

//namespace {

class CHuyacc
{
public:
    CHuyacc() = default;

    template<typename TStream>
    bool huyacc(const std::vector<SParseTerm>& term_vec,
                const std::vector<SParseRule>& rule_vec, 
                TStream& out_stream);

private:
    template<typename TStream>
    bool huyacc_main(const std::vector<SParseRule>& rule_vec, 
                     TStream& out_stream);

    template<typename TStream>
    bool huyacc_includes(TStream& out_stream);
    template<typename TStream>
    bool huyacc_structure(TStream& out_stream);

    template<typename TStream>
    bool huyacc_enum(const std::vector<SParseRule>& rule_vec, 
                     TStream& out_stream);
    template<typename TStream>
    bool huyacc_array(const std::vector<SParseRule>& rule_vec, 
                      TStream& out_stream);
    template<typename TStream>
    bool huyacc_build_term(TStream& out_stream);
    template<typename TStream>
    bool huyacc_build_rule(const std::vector<SParseRule>& rule_vec, 
                           TStream& out_stream);

    template<typename TStream>
    bool huyacc_enumitem(const SParseRule& rule, 
                         TStream& out_stream);
    template<typename TStream>
    bool huyacc_instance(const SParseRule& rule, 
                         TStream& out_stream);
    template<typename TStream>
    bool huyacc_function(const SParseRule& rule, 
                         TStream& out_stream);

private:
    CBuilder builder;
};

template<typename TStream>
bool CHuyacc::huyacc(const std::vector<SParseTerm>& term_vec,
                     const std::vector<SParseRule>& rule_vec, 
                     TStream& out_stream)
{
    CBuilderContext builder_context;

    if (!builder_context.add_term("imm")) return false;
    if (!builder_context.add_term("lit")) return false;
    for (const auto& term: term_vec)
        if (!builder_context.add_term(term.name_view)) return false;
    
    for (const auto& rule: rule_vec)
        if (!builder_context.add_rule(rule.name_view)) return false;

    builder = CBuilder(std::move(builder_context));

    out_stream << "//Warning! Do not edit this file!" "\n";
    out_stream << "//This file was auto - generated by HUYACC" "\n";
    out_stream << "//Edit HUYACC input file instead" "\n";

    out_stream << "#ifndef HUYACCER_H" "\n";
    out_stream << "#define HUYACCER_H" "\n";

    if (!huyacc_enum(rule_vec, out_stream)) return false;
    if (!huyacc_includes(out_stream)) return false;
    if (!huyacc_structure(out_stream)) return false;
    if (!huyacc_array(rule_vec, out_stream)) return false;
    
    if (!huyacc_main(rule_vec, out_stream)) return false;

    if (!huyacc_build_term(out_stream)) return false;

    for (const auto& rule : rule_vec)
    {
        if (!huyacc_function(rule, out_stream)) 
            return false;
    }

    if (!huyacc_build_rule(rule_vec, out_stream)) return false;

    out_stream << "#endif //HUYACCER_H" "\n";

    return true;
}

template<typename TStream>
bool CHuyacc::huyacc_main(const std::vector<SParseRule>& rule_vec, 
                          TStream& out_stream)
{
    out_stream <<
    "YYNODE huyacc(const std::vector<SLexem>& term_vec)" "\n"
    "{\n"
    "    YYNODE YYLVAL = {};" "\n"
    "    \n"
    "    SMatchContext context = { 0u, {} };" "\n"
    "    \n"
    "    if (GlobalRuleArray.front().expr && " "\n"
    "        GlobalRuleArray.front().expr->try_match(term_vec, context))" "\n"
    "        YYLVAL = *(context.node_vec.front());" "\n"
    "    \n"
    "    return YYLVAL;" "\n"
    "}\n";

    return true;
}

template<typename TStream>
bool CHuyacc::huyacc_includes(TStream& out_stream)
{
    out_stream << "#include <string_view>" "\n";
    out_stream << "#include <memory>" "\n";
    out_stream << "#include <vector>" "\n";
    out_stream << "#include <array>" "\n";
    out_stream << "#include \"SHuyaccLexem.h\"" "\n";
    out_stream << "#include \"SFlexxTerm.h\"" "\n";
    out_stream << "#include \"SHuyaccNode.h\"" "\n";
    out_stream << "using YYTERM = SFlexxTerm;" "\n";
    out_stream << "using YYNODE = SHuyaccNode;" "\n";

    return true;
}

template<typename TStream>
bool CHuyacc::huyacc_structure(TStream& out_stream)
{
    out_stream << 
    "struct SRule" "\n"
    "{\n"
    "    ERuleType type;" "\n"
    "    std::string_view name;" "\n"
    "    std::shared_ptr<SHuyaccLexem> expr;" "\n"
    "};\n";

    return true;
}

template<typename TStream>
bool CHuyacc::huyacc_enum(const std::vector<SParseRule>& rule_vec, 
                          TStream& out_stream)
{
    out_stream << "enum ERuleType" "\n";
    out_stream << "{" "\n";

    for (const auto& rule : rule_vec)
        huyacc_enumitem(rule, out_stream);

    out_stream << "\t" "RULES_CNT" "\n";
    out_stream << "};" "\n";

    return true;
}

template<typename TStream>
bool CHuyacc::huyacc_array(const std::vector<SParseRule>& rule_vec, 
                           TStream& out_stream)
{
    out_stream << "const std::array<SRule, RULES_CNT> ";
    out_stream << "GlobalRuleArray = {" "\n";
    out_stream << "    {" "\n";

    for (const auto& rule : rule_vec)
    {
        huyacc_instance(rule, out_stream);
        out_stream << ",\n";
    }

    out_stream << "    }" "\n";
    out_stream << "};" "\n";

    return true;
}

template<typename TStream>
bool CHuyacc::huyacc_build_term(TStream& out_stream)
{
    out_stream << 
    "YYNODE build_huyacc_term(ETermType type, const SLexem& lexem)" "\n"
    "{\n"
    "    YYNODE result = {};" "\n"
    "    if (type == lexem.type)" "\n"
    "        result = YYNODE{lexem.term};" "\n"
    "    else" "\n"
    "        result = {};" "\n"
    "    \n"
    "    return result;" "\n"
    "}\n";

    return true;
}

template<typename TStream>
bool CHuyacc::huyacc_build_rule(const std::vector<SParseRule>& rule_vec, 
                                TStream& out_stream)
{
    out_stream << 
    "YYNODE build_huyacc_rule"
    "(ERuleType type, const std::vector<YYNODE>& YYLIST)" "\n"
    "{\n"
    "    YYNODE result = {};" "\n"
    "    switch (type)" "\n"
    "    {\n";

    for (const auto& rule : rule_vec)
    {
        out_stream << 
        "    case RULE_" << rule.name_view << ":\n"
        "        result = huyacc_" << rule.name_view << "(YYLIST);\n"
        "        break;" "\n";
    }

    out_stream << 
    "    default:\n"
    "        result = {};\n"
    "        break;\n"
    "    }\n"
    "    \n"
    "    return result;" "\n"
    "}\n";

    return true;
}

template<typename TStream>
bool CHuyacc::huyacc_enumitem(const SParseRule& rule, 
                              TStream& out_stream)
{
    out_stream << "\t" "RULE_" << rule.name_view << ",\n"; 

    return true;
}

template<typename TStream>
bool CHuyacc::huyacc_instance(const SParseRule& rule, 
                              TStream& out_stream)
{
    auto node = builder.parse(rule.expr_view);

    out_stream << "\t{" "\n";
    out_stream << "\t    RULE_" << rule.name_view << ",\n"; 
    out_stream << "\t    \"" << rule.name_view << "\",\n"; 

    if (node) node->build_parse(out_stream);
    else      out_stream << "nullptr";

    out_stream << "\n";
    out_stream << "\t}";

    return true;
}

template<typename TStream>
bool CHuyacc::huyacc_function(const SParseRule& rule, 
                              TStream& out_stream)
{
    out_stream << "YYNODE huyacc_" << rule.name_view;
    out_stream << "(const std::vector<YYNODE>& YYLIST)" "\n";
    out_stream << "{\n";
    out_stream << "    YYNODE YYLVAL = {};" "\n";
    out_stream << rule.code_view << "\n";
    out_stream << "    return YYLVAL;" "\n";
    out_stream << "}\n";

    return true;
}

//} //namespace

#endif //CHUYACC_H
