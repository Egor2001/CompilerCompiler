#ifndef CFLEXX_H
#define CFLEXX_H

#include <optional>
#include <string_view>
#include <regex>

#include "../parser/SParseTerm.h"

//namespace huyacc {

class CFlexx
{
public:
    CFlexx() = default;

    template<typename TStream>
    bool flexx(const std::vector<SParseTerm>& term_vec,
               TStream& out_stream);

private:
    template<typename TStream>
    bool flexx_main(const std::vector<SParseTerm>& term_vec,
                    TStream& out_stream); 
    template<typename TStream>
    bool flexx_funclexem(const std::vector<SParseTerm>& term_vec,
                         TStream& out_stream); 

    template<typename TStream>
    bool flexx_includes(TStream& out_stream);
    template<typename TStream>
    bool flexx_structure(TStream& out_stream);

    template<typename TStream>
    bool flexx_enum(const std::vector<SParseTerm>& term_vec,
                    TStream& out_stream);
    template<typename TStream>
    bool flexx_array(const std::vector<SParseTerm>& term_vec,
                     TStream& out_stream);

    template<typename TStream>
    bool flexx_enumitem(const SParseTerm& term, TStream& out_stream);
    template<typename TStream>
    bool flexx_instance(const SParseTerm& term, TStream& out_stream);
    template<typename TStream>
    bool flexx_function(const SParseTerm& term, TStream& out_stream);

private:
};

template<typename TStream>
bool CFlexx::flexx(const std::vector<SParseTerm>& term_vec,
                   TStream& out_stream)
{
    out_stream << "//Warning! Do not edit this file!" "\n";
    out_stream << "//This file was auto - generated by FLEXX" "\n";
    out_stream << "//Edit FLEXX input file instead" "\n";

    out_stream << "#ifndef FLEXXER_H" "\n";
    out_stream << "#define FLEXXER_H" "\n";

    if (!flexx_includes(out_stream))        return false;
    if (!flexx_enum(term_vec, out_stream))  return false;
    if (!flexx_structure(out_stream))       return false;
    if (!flexx_array(term_vec, out_stream)) return false;

    for (const auto& term : term_vec)
        if (!flexx_function(term, out_stream)) 
            return false;

    if (!flexx_funclexem(term_vec, out_stream)) return false;
    if (!flexx_main(term_vec, out_stream))      return false;

    out_stream << "#endif //FLEXXER_H" "\n";

    return true;
}

template<typename TStream>
bool CFlexx::flexx_main(const std::vector<SParseTerm>& term_vec,
                        TStream& out_stream)
{
    out_stream << 
    "std::size_t flexx(std::string_view text_view,\n"
    "                  std::vector<SLexem>& flexx_vec)" "\n"
    "{\n"
    "    std::size_t result = 0u;" "\n"
    "    std::size_t skip = 0u;" "\n"
    "    while ((skip = flexx_lexem(text_view, flexx_vec)))" "\n"
    "    {\n"
    "        text_view.remove_prefix(skip);" "\n"
    "        result += skip;" "\n"
    "        \n"
    "        skip = text_view.find_first_not_of(\" \\t\\r\\n\");" "\n"
    "        text_view.remove_prefix(std::min(skip, text_view.size()));" "\n"
    "        result += skip;" "\n"
    "    }\n"
    "    \n"
    "    return result;" "\n"
    "}\n";

    return true;
}

template<typename TStream>
bool CFlexx::flexx_funclexem(const std::vector<SParseTerm>& term_vec,
                             TStream& out_stream)
{
    out_stream << 
    "std::size_t flexx_lexem(const std::string_view& text_view,\n"
    "                        std::vector<SLexem>& flexx_vec)" "\n"
    "{\n"
    "    std::size_t result = 0u;" "\n"
    "    std::size_t subresult = 0u;" "\n"
    "    SLexem cur_lexem = {};" "\n";

    for (const auto& term : term_vec)
    {
        out_stream << 
        "    if ((subresult = GlobalTermArray[TERM_" << term.name_view << "]"
        ".try_match(text_view)) > result)" "\n"
        "    {\n"
        "        result = subresult;" "\n"
        "        cur_lexem.type = TERM_" << term.name_view << ";\n"
        "        cur_lexem.term = flexx_" << term.name_view << 
        "(text_view.substr(0u, result));" "\n"
        "    }\n";
    }

    out_stream << 
    "    if (!text_view.empty() && "
    "std::isalpha(text_view.front()))" "\n"
    "    {\n"
    "        subresult = 0u;" "\n"
    "        while (subresult < text_view.size() &&" "\n"
    "               std::isalnum(text_view[subresult]))" "\n"
    "            ++subresult;" "\n"
    "    \n"
    "        if (subresult > result)" "\n"
    "        {\n"
    "            result = subresult;" "\n"
    "            auto term_view = text_view.substr(0u, result);" "\n"
    "            cur_lexem.type = TERM_lit;" "\n"
    "            cur_lexem.term = SFlexxTerm("
    "std::string(term_view.data(), term_view.size()));" "\n"
    "        }\n"
    "    }\n"
    "    else if (!text_view.empty() && " "\n"
    "             std::isdigit(text_view.front()))" "\n"
    "    {\n"
    "        subresult = 0u;" "\n"
    "        while (subresult < text_view.size() &&" "\n"
    "               std::isdigit(text_view[subresult]))" "\n"
    "            ++subresult;" "\n"
    "    \n"
    "        if (subresult > result)" "\n"
    "        {\n"
    "            auto beg = text_view.data();" "\n"
    "            auto end = text_view.data() + subresult;" "\n"
    "            int32_t data = 0;" "\n"
    "            auto [next_ptr, err_code] = "
    "std::from_chars(beg, end, data);" "\n"
    "            if (err_code == std::errc{})" "\n"
    "            {\n"
    "                result = subresult;" "\n"
    "                cur_lexem.type = TERM_imm;" "\n"
    "                cur_lexem.term = SFlexxTerm(data);" "\n"
    "            }\n"
    "        }\n"
    "    }\n";

    out_stream << 
    "    if (result)" "\n"
    "        flexx_vec.push_back(cur_lexem);" "\n"
    "    \n"
    "    return result;" "\n"
    "}\n";

    return true;
}

template<typename TStream>
bool CFlexx::flexx_includes(TStream& out_stream)
{
    out_stream << "#include <string_view>" "\n";
    out_stream << "#include <charconv>" "\n";
    //out_stream << "#include <regex>" "\n";
    out_stream << "#include <vector>" "\n";
    out_stream << "#include <array>" "\n";
    out_stream << "#include \"SFlexxTerm.h\"" "\n";
    out_stream << "using YYTERM = SFlexxTerm;" "\n";

    return true;
}

template<typename TStream>
bool CFlexx::flexx_structure(TStream& out_stream)
{
    out_stream << 
    "struct SLexem" "\n"
    "{\n"
    "    ETermType type;" "\n"
    "    YYTERM    term;" "\n"
    "};\n";

    out_stream << 
    "struct STerm" "\n"
    "{\n"
    "    std::size_t try_match"
        "(const std::string_view& text_view) const;\n"
    "    \n"
    "    ETermType type;\n"
    "    std::string_view name;\n"
    "    std::string_view expr;\n"
    "};\n";

    out_stream << 
    "std::size_t STerm::try_match"
    "(const std::string_view& text_view) const" "\n"
    "{\n"
    "    std::size_t result = 0u;" "\n"
    "    if (text_view.compare(0u, expr.size(), expr) == 0)" "\n"
    "        result = expr.size();" "\n"
    "    " "\n"
    "    return result;" "\n"
    "}\n";

    return true;
}

template<typename TStream>
bool CFlexx::flexx_enum(const std::vector<SParseTerm>& term_vec,
                        TStream& out_stream)
{
    out_stream << "enum ETermType" "\n";
    out_stream << "{" "\n";
    for (const auto& term : term_vec)
        if (!flexx_enumitem(term, out_stream)) 
            return false;
    out_stream << "\t" "TERMS_CNT," "\n";
    out_stream << "\t" "TERM_lit," "\n";
    out_stream << "\t" "TERM_imm" "\n";
    out_stream << "};" "\n";

    return true;
}

template<typename TStream>
bool CFlexx::flexx_array(const std::vector<SParseTerm>& term_vec,
                         TStream& out_stream)
{
    out_stream << "const std::array<STerm, TERMS_CNT>";
    out_stream << "GlobalTermArray = {" "\n";
    out_stream << "    {\n";
    for (const auto& term : term_vec)
    {
        if (!flexx_instance(term, out_stream)) 
            return false;

        out_stream << ",\n";
    }
    out_stream << "    }\n";
    out_stream << "};" "\n";

    return true;
}

template<typename TStream>
bool CFlexx::flexx_enumitem(const SParseTerm& term,
                            TStream& out_stream)
{
    out_stream << "\t" "TERM_" << term.name_view << ",\n";
    
    return true;
}

template<typename TStream>
bool CFlexx::flexx_instance(const SParseTerm& term,
                            TStream& out_stream)
{
    out_stream << "\t";
    out_stream << "{ ";
    out_stream << "TERM_"  << term.name_view << "";
    out_stream << ", ";
    out_stream << "\""  << term.name_view << "\"";
    out_stream << ", ";
    //out_stream << "std::regex(\"" << term.expr_view << "\") ";
    out_stream << "\"" << term.expr_view << "\" ";
    out_stream << "}";
    
    return true;
}

template<typename TStream>
bool CFlexx::flexx_function(const SParseTerm& term,
                            TStream& out_stream)
{
    out_stream << "YYTERM " "flexx_" << term.name_view << 
                  "(const std::string_view& YYTEXT)\n"
                  "{\n"
                  "    YYTERM YYLVAL = {};" "\n";
    out_stream <<      term.code_view << "\n"  
                  "    return YYLVAL;" "\n"
                  "}\n";
    
    return true;
}

//} //namespace huyacc

#endif //CFLEXX_H
